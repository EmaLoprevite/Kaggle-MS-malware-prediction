#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import os
import numpy as np
import pandas as pd
import logging
import pickle
import time


# In[ ]:


# Choose the model and customise only the full_pipeline,
# the model and param_grid in training.ipynb if needed

#MODEL_NAME = "DecisionTreeClassifier"
#MODEL_NAME = "RandomForestClassifier"
#MODEL_NAME = "AdaBoostClassifier"
MODEL_NAME = "GradientBoostingClassifier"

ROUND = "r2"

DATASET_NAME = "train.csv"
if NB == "PREDICTION":
    DATASET_NAME = "test.csv"

DATASET_PATH = os.path.join("..", "space", "kaggle-ms-challenge")
LOG_PATH = "log"
PICKLE_PATH = "pickle"
IMAGES_PATH = "images"
CSV_PATH = os.path.join(os.environ['HOME'], "space", "predictions")

MODEL_PKL = os.path.join(
    PICKLE_PATH,
    "{}-{}-model.pickle".format(ROUND, MODEL_NAME)
)
PIPELINE_PKL = os.path.join(
    PICKLE_PATH,
    "{}-{}-pipeline.pickle".format(ROUND, MODEL_NAME)
)
MODEL_SEARCH_PKL = os.path.join(
    PICKLE_PATH,
    "{}-{}-search.pickle".format(ROUND, MODEL_NAME)
)

N_CORES = 6
N_THREADS = 6
os.environ['NUMEXPR_MAX_THREADS'] = str(N_THREADS)


# In[ ]:


logging.basicConfig(
    filename=os.path.join(
        LOG_PATH,
        "{}-{}.log".format(ROUND, MODEL_NAME)
    ),
    level=logging.INFO,
    format="%(asctime)s:%(levelname)s:%(message)s"
)


# In[ ]:


def load_data(ds_path, ds_name, dict_dtypes):
    csv_path = os.path.join(ds_path, ds_name)
    return pd.read_csv(csv_path, dtype=dict_dtypes)  # nrows for quick tests


# In[ ]:


logging.info("STARTING %s --- %s, %s", NB, ROUND, MODEL_NAME)

logging.info("Number of cores: %s, NUMEXPR_MAX_THREADS = %s", N_CORES, N_THREADS)


# In[ ]:


# Array with numeric columns (labels "HasDetection" excluded)
name_col_num = [
    'IsBeta',  # boolean
    'RtpStateBitfield',  # nominal
    'IsSxsPassiveMode',  # boolean
    'DefaultBrowsersIdentifier',  # nominal
    'AVProductStatesIdentifier',  # nominal
    'AVProductsInstalled',  # nominal
    'AVProductsEnabled',  # nominal
    'HasTpm',  # boolean
    'CountryIdentifier',  # nominal
    'CityIdentifier',  # nominal
    'OrganizationIdentifier',  # nominal
    'GeoNameIdentifier',  # nominal
    'LocaleEnglishNameIdentifier',  # nominal
    'OsBuild',  # ordinal
    'OsSuite',  # ordinal
    'IsProtected',  # boolean
    'AutoSampleOptIn',  # boolean
    'SMode',  # boolean
    'IeVerIdentifier',  # nominal
    'Firewall',  # boolean
    'UacLuaenable',  # nominal
    'Census_OEMNameIdentifier',  # nominal
    'Census_OEMModelIdentifier',  # nominal
    'Census_ProcessorCoreCount',  # ordinal
    'Census_ProcessorManufacturerIdentifier',  # nominal
    'Census_ProcessorModelIdentifier',  # nominal
    'Census_PrimaryDiskTotalCapacity',  # ordinal
    'Census_SystemVolumeTotalCapacity',  # ordinal
    'Census_HasOpticalDiskDrive',  # boolean
    'Census_TotalPhysicalRAM',  # ordinal
    'Census_InternalPrimaryDiagonalDisplaySizeInInches',  # ordinal
    'Census_InternalPrimaryDisplayResolutionHorizontal',  # ordinal
    'Census_InternalPrimaryDisplayResolutionVertical',  # ordinal
    'Census_InternalBatteryNumberOfCharges',  # ordinal
    'Census_OSBuildNumber',  # ordinal
    'Census_OSBuildRevision',  # ordinal
    'Census_OSInstallLanguageIdentifier',  # nominal
    'Census_OSUILocaleIdentifier',  # nominal
    'Census_IsPortableOperatingSystem',  # boolean
    'Census_IsFlightingInternal',  # boolean
    'Census_IsFlightsDisabled',  # boolean
    'Census_ThresholdOptIn',  # boolean
    'Census_FirmwareManufacturerIdentifier',  # nominal
    'Census_FirmwareVersionIdentifier',  # nominal
    'Census_IsSecureBootEnabled',  # boolean
    'Census_IsWIMBootEnabled',  # boolean
    'Census_IsVirtualDevice',  # boolean
    'Census_IsTouchEnabled',  # boolean
    'Census_IsPenCapable',  # boolean
    'Census_IsAlwaysOnAlwaysConnectedCapable',  # boolean
    'Wdft_IsGamer',  # boolean
    'Wdft_RegionIdentifier'  # nominal
]

# Dictionary with associated dtypes (labels "HasDetection" included)
dict_col_num_dtypes = {
    'IsBeta': np.uint8,
    'RtpStateBitfield': np.float16,  # np.uint8,
    'IsSxsPassiveMode': np.uint8,
    'DefaultBrowsersIdentifier': np.float16,  # np.uint16,
    'AVProductStatesIdentifier': np.float32,  # np.uint32,
    'AVProductsInstalled': np.float16,  # np.uint8,
    'AVProductsEnabled': np.float16,  # np.uint8,
    'HasTpm': np.uint8,
    'CountryIdentifier': np.uint8,
    'CityIdentifier': np.float32,  # np.uint32,
    'OrganizationIdentifier': np.float16,  # np.uint8,
    'GeoNameIdentifier': np.float16,  # np.uint16,
    'LocaleEnglishNameIdentifier': np.uint16,
    'OsBuild': np.uint16,
    'OsSuite': np.uint16,
    'IsProtected': np.float16,  # np.uint8,
    'AutoSampleOptIn': np.uint8,
    'SMode': np.float16,  # np.uint8,
    'IeVerIdentifier': np.float16,  # np.uint16,
    'Firewall': np.float16,  # np.uint8,
    'UacLuaenable': np.float32,  # np.uint32,
    'Census_OEMNameIdentifier': np.float16,  # np.uint16,
    'Census_OEMModelIdentifier': np.float32,  # np.uint16,
    'Census_ProcessorCoreCount': np.float16,  # np.uint8,
    'Census_ProcessorManufacturerIdentifier': np.float16,  # np.uint8,
    'Census_ProcessorModelIdentifier': np.float16,  # np.uint16,
    'Census_PrimaryDiskTotalCapacity': np.float64,  # np.uint64,
    'Census_SystemVolumeTotalCapacity': np.float32,  # np.uint32,
    'Census_HasOpticalDiskDrive': np.uint8,
    'Census_TotalPhysicalRAM': np.float32,  # np.uint32,
    'Census_InternalPrimaryDiagonalDisplaySizeInInches': np.float16,
    'Census_InternalPrimaryDisplayResolutionHorizontal': np.float16,  # np.int16,
    'Census_InternalPrimaryDisplayResolutionVertical': np.float16,  # np.int16,
    'Census_InternalBatteryNumberOfCharges': np.float64,  # np.uint32,
    'Census_OSBuildNumber': np.uint16,
    'Census_OSBuildRevision': np.uint8,
    'Census_OSInstallLanguageIdentifier': np.float16,  # np.uint8,
    'Census_OSUILocaleIdentifier': np.uint8,
    'Census_IsPortableOperatingSystem': np.uint8,
    'Census_IsFlightingInternal': np.float16,  # np.uint8,
    'Census_IsFlightsDisabled': np.float16,  # np.uint8,
    'Census_ThresholdOptIn': np.float16,  # np.uint8,
    'Census_FirmwareManufacturerIdentifier': np.float16,  # np.uint16,
    'Census_FirmwareVersionIdentifier': np.float32,  # np.uint32,
    'Census_IsSecureBootEnabled': np.uint8,
    'Census_IsWIMBootEnabled': np.float16,  # np.uint8,
    'Census_IsVirtualDevice': np.float16,  # np.uint8,
    'Census_IsTouchEnabled': np.uint8,
    'Census_IsPenCapable': np.uint8,
    'Census_IsAlwaysOnAlwaysConnectedCapable': np.float16,  # np.uint8,
    'Wdft_IsGamer': np.float16,  # np.uint8,
    'Wdft_RegionIdentifier': np.float16,  # np.uint8,
    'HasDetections': np.uint8
}


# In[ ]:


# Array with string columns
name_col_str = [
    'MachineIdentifier',
    'ProductName',
    'EngineVersion',
    'AppVersion',
    'AvSigVersion',
    'Platform',
    'Processor',
    'OsVer',
    'OsPlatformSubRelease',
    'OsBuildLab',
    'SkuEdition',
    'PuaMode',
    'SmartScreen',
    'Census_MDC2FormFactor',
    'Census_DeviceFamily',
    'Census_ProcessorClass',
    'Census_PrimaryDiskTypeName',
    'Census_ChassisTypeName',
    'Census_PowerPlatformRoleName',
    'Census_InternalBatteryType',
    'Census_OSVersion',
    'Census_OSArchitecture',
    'Census_OSBranch',
    'Census_OSEdition',
    'Census_OSSkuName',
    'Census_OSInstallTypeName',
    'Census_OSWUAutoUpdateOptionsName',
    'Census_GenuineStateName',
    'Census_ActivationChannel',
    'Census_FlightRing'
]

# Dictionary with associated dtypes
dict_col_str_dtypes = {
    'MachineIdentifier': np.string_,
    'ProductName': np.string_,
    'EngineVersion': np.string_,
    'AppVersion': np.string_,
    'AvSigVersion': np.string_,
    'Platform': np.string_,
    'Processor': np.string_,
    'OsVer': np.string_,
    'OsPlatformSubRelease': np.string_,
    'OsBuildLab': np.string_,
    'SkuEdition': np.string_,
    'PuaMode': np.string_,
    'SmartScreen': np.string_,
    'Census_MDC2FormFactor': np.string_,
    'Census_DeviceFamily': np.string_,
    'Census_ProcessorClass': np.string_,
    'Census_PrimaryDiskTypeName': np.string_,
    'Census_ChassisTypeName': np.string_,
    'Census_PowerPlatformRoleName': np.string_,
    'Census_InternalBatteryType': np.unicode_,  # not np.string_
    'Census_OSVersion': np.string_,
    'Census_OSArchitecture': np.string_,
    'Census_OSBranch': np.string_,
    'Census_OSEdition': np.string_,
    'Census_OSSkuName': np.string_,
    'Census_OSInstallTypeName': np.string_,
    'Census_OSWUAutoUpdateOptionsName': np.string_,
    'Census_GenuineStateName': np.string_,
    'Census_ActivationChannel': np.string_,
    'Census_FlightRing': np.string_
}


# In[ ]:


# union of dictionaries
DICT_DTYPES = {**dict_col_num_dtypes, **dict_col_str_dtypes}

logging.info("Load data set csv file")
t0 = time.perf_counter()
ds = load_data(DATASET_PATH, DATASET_NAME, DICT_DTYPES)
t1 = time.perf_counter()
t_load = t1 - t0
logging.info("Load data set csv file, time: %s seconds", t_load)


# In[ ]:


logging.info("Dataset shape: %s", ds.shape)


# In[ ]:


if NB == "PREDICTION":
    df = pd.DataFrame(ds['MachineIdentifier'])


# In[ ]:


# see statistics.ipynb to understand why I remove these features

pop_num = [
    #'DefaultBrowsersIdentifier',
    #'Census_IsFlightingInternal',
    'IsBeta',
    'AutoSampleOptIn',
    'Census_IsPortableOperatingSystem',
    'UacLuaenable',
    'Census_IsVirtualDevice',
    #'HasTpm',
    #'IsSxsPassiveMode',
    #'Census_IsFlightsDisabled'
    'Census_SystemVolumeTotalCapacity'
]
for v in pop_num:
    ds.pop(v)
    name_col_num.remove(v)

pop_str = [
    'MachineIdentifier',
    'PuaMode',
    'Census_ProcessorClass',
    'Census_DeviceFamily'
    #'ProductName'
]
for v in pop_str:
    ds.pop(v)
    name_col_str.remove(v)


# In[ ]:


if NB == "TRAINING":
    ds_labels = ds.pop("HasDetections").values


# In[ ]:


# split the list of boolean numerical features
name_col_num_bool = [
    'IsBeta',  # boolean
    'IsSxsPassiveMode',  # boolean
    'HasTpm',  # boolean
    'IsProtected',  # boolean
    'AutoSampleOptIn',  # boolean
    'SMode',  # boolean
    'Firewall',  # boolean
    'Census_HasOpticalDiskDrive',  # boolean
    'Census_IsPortableOperatingSystem',  # boolean
    'Census_IsFlightingInternal',  # boolean
    'Census_IsFlightsDisabled',  # boolean
    'Census_ThresholdOptIn',  # boolean
    'Census_IsSecureBootEnabled',  # boolean
    'Census_IsWIMBootEnabled',  # boolean
    'Census_IsVirtualDevice',  # boolean
    'Census_IsTouchEnabled',  # boolean
    'Census_IsPenCapable',  # boolean
    'Census_IsAlwaysOnAlwaysConnectedCapable',  # boolean
    'Wdft_IsGamer',  # boolean
]

for v in pop_num:
    if v in name_col_num_bool:
        name_col_num_bool.remove(v)

for v in name_col_num_bool:
    name_col_num.remove(v)


# In[ ]:


# split the list of nominal numerical features
name_col_num_bin = [
    'RtpStateBitfield',  # nominal
    'DefaultBrowsersIdentifier',  # nominal
    'AVProductStatesIdentifier',  # nominal
    'AVProductsInstalled',  # nominal
    'AVProductsEnabled',  # nominal
    'CountryIdentifier',  # nominal
    'CityIdentifier',  # nominal
    'OrganizationIdentifier',  # nominal
    'GeoNameIdentifier',  # nominal
    'LocaleEnglishNameIdentifier',  # nominal
    'IeVerIdentifier',  # nominal
    'UacLuaenable',  # nominal
    'Census_OEMNameIdentifier',  # nominal
    'Census_OEMModelIdentifier',  # nominal
    'Census_ProcessorManufacturerIdentifier',  # nominal
    'Census_ProcessorModelIdentifier',  # nominal
    'Census_OSInstallLanguageIdentifier',  # nominal
    'Census_OSUILocaleIdentifier',  # nominal
    'Census_FirmwareManufacturerIdentifier',  # nominal
    'Census_FirmwareVersionIdentifier',  # nominal
    'Wdft_RegionIdentifier'  # nominal
]

for v in pop_num:
    if v in name_col_num_bin:
        name_col_num_bin.remove(v)

for v in name_col_num_bin:
    name_col_num.remove(v)


# In[ ]:


logging.info("Numeric columns: %s", name_col_num)


# In[ ]:


logging.info("Boolen columns: %s", name_col_num_bool)


# In[ ]:


logging.info("Numeric bin columns: %s", name_col_num_bin)


# In[ ]:


logging.info("String columns: %s", name_col_str)


# In[ ]:


# Custom Transformers
# TrasformerMixin for fit_tranform(),
# BaseEstimator for get_params() and set_params() but
# no *args and **kargs in the constructor
from sklearn.base import BaseEstimator, TransformerMixin


# Handle Pandas DataFrame for Scikit-Learn
class DataFrameSelector(BaseEstimator, TransformerMixin):
    def __init__(self, attribute_names):
        self.attribute_names = attribute_names

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        return X[self.attribute_names].values


# In[ ]:


# Threshold for rare values
THRESHOLD = 100


# In[ ]:


# Change numeric rare values
class RareNumericValues(BaseEstimator, TransformerMixin):
    def __init__(self, attribute_names):
        self.attribute_names = attribute_names

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        for c in self.attribute_names:
            counts = X[c].value_counts()
            if counts[counts < THRESHOLD].size != 0:
                X[c].replace(
                    to_replace=counts[counts < THRESHOLD].index,
                    value=-111,
                    inplace=True
                ) 
        return X[self.attribute_names].values


# In[ ]:


# Fix the content of the string columns
# np.nan (float) becomes nan (string)
# and rare values become a sentinel value
class FixStringColumns(BaseEstimator, TransformerMixin):
    def __init__(self, attribute_names):
        self.attribute_names = attribute_names

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        for c in self.attribute_names:
            X[c] = X[c].apply(lambda s: str(s).lower().strip())
            #counts = X[c].value_counts()
            #if counts[counts < THRESHOLD].size != 0:
            #    X[c].replace(
            #        to_replace=counts[counts < THRESHOLD].index,
            #        value="my-other",
            #        inplace=True
            #    )
        return X[self.attribute_names]  # .values


# In[ ]:


# Frequency encoding for both numerical and categorical features
# it works with a pd.DataFrame
class FrequencyEncoding(BaseEstimator, TransformerMixin):
    def __init__(self):
        pass

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X = pd.DataFrame(X)
        for c in X.columns:
            fe = X[c].value_counts()/len(X)
            X.loc[:, c] = X[c].map(fe)
        return X.values

