#!/usr/bin/env python
# coding: utf-8

# In[1]:


import os
import numpy as np
import pandas as pd


def load_data(ds_path, ds_name, dict_dtypes):
    csv_path = os.path.join(ds_path, ds_name)
    return pd.read_csv(csv_path, dtype=dict_dtypes)

DATASET_PATH = "../space/kaggle-ms-challenge/"
DATASET_NAME = "train.csv"


# In[2]:


# Dictionary with associated dtypes (labels "HasDetection" included)
dict_col_num_dtypes = {
    'IsBeta': np.uint8,
    'RtpStateBitfield': np.float16,  # np.uint8,
    'IsSxsPassiveMode': np.uint8,
    'DefaultBrowsersIdentifier': np.float16,  # np.uint16,
    'AVProductStatesIdentifier': np.float32,  # np.uint32,
    'AVProductsInstalled': np.float16,  # np.uint8,
    'AVProductsEnabled': np.float16,  # np.uint8,
    'HasTpm': np.uint8,
    'CountryIdentifier': np.uint8,
    'CityIdentifier': np.float32,  # np.uint32,
    'OrganizationIdentifier': np.float16,  # np.uint8,
    'GeoNameIdentifier': np.float16,  # np.uint16,
    'LocaleEnglishNameIdentifier': np.uint16,
    'OsBuild': np.uint16,
    'OsSuite': np.uint16,
    'IsProtected': np.float16,  # np.uint8,
    'AutoSampleOptIn': np.uint8,
    'SMode': np.float16,  # np.uint8,
    'IeVerIdentifier': np.float16,  # np.uint16,
    'Firewall': np.float16,  # np.uint8,
    'UacLuaenable': np.float32,  # np.uint32,
    'Census_OEMNameIdentifier': np.float16,  # np.uint16,
    'Census_OEMModelIdentifier': np.float32,  # np.uint16,
    'Census_ProcessorCoreCount': np.float16,  # np.uint8,
    'Census_ProcessorManufacturerIdentifier': np.float16,  # np.uint8,
    'Census_ProcessorModelIdentifier': np.float16,  # np.uint16,
    'Census_PrimaryDiskTotalCapacity': np.float64,  # np.uint64,
    'Census_SystemVolumeTotalCapacity': np.float32,  # np.uint32,
    'Census_HasOpticalDiskDrive': np.uint8,
    'Census_TotalPhysicalRAM': np.float32,  # np.uint32,
    'Census_InternalPrimaryDiagonalDisplaySizeInInches': np.float16,
    'Census_InternalPrimaryDisplayResolutionHorizontal': np.float16,  # np.int16,
    'Census_InternalPrimaryDisplayResolutionVertical': np.float16,  # np.int16,
    'Census_InternalBatteryNumberOfCharges': np.float64,  # np.uint32,
    'Census_OSBuildNumber': np.uint16,
    'Census_OSBuildRevision': np.uint8,
    'Census_OSInstallLanguageIdentifier': np.float16,  # np.uint8,
    'Census_OSUILocaleIdentifier': np.uint8,
    'Census_IsPortableOperatingSystem': np.uint8,
    'Census_IsFlightingInternal': np.float16,  # np.uint8,
    'Census_IsFlightsDisabled': np.float16,  # np.uint8,
    'Census_ThresholdOptIn': np.float16,  # np.uint8,
    'Census_FirmwareManufacturerIdentifier': np.float16,  # np.uint16,
    'Census_FirmwareVersionIdentifier': np.float32,  # np.uint32,
    'Census_IsSecureBootEnabled': np.uint8,
    'Census_IsWIMBootEnabled': np.float16,  # np.uint8,
    'Census_IsVirtualDevice': np.float16,  # np.uint8,
    'Census_IsTouchEnabled': np.uint8,
    'Census_IsPenCapable': np.uint8,
    'Census_IsAlwaysOnAlwaysConnectedCapable': np.float16,  # np.uint8,
    'Wdft_IsGamer': np.float16,  # np.uint8,
    'Wdft_RegionIdentifier': np.float16,  # np.uint8,
    'HasDetections': np.uint8
}


# In[3]:


# Dictionary with associated dtypes
dict_col_str_dtypes = {
    'MachineIdentifier': np.string_,
    'ProductName': np.string_,
    'EngineVersion': np.string_,
    'AppVersion': np.string_,
    'AvSigVersion': np.string_,
    'Platform': np.string_,
    'Processor': np.string_,
    'OsVer': np.string_,
    'OsPlatformSubRelease': np.string_,
    'OsBuildLab': np.string_,
    'SkuEdition': np.string_,
    'PuaMode': np.string_,
    'SmartScreen': np.string_,
    'Census_MDC2FormFactor': np.string_,
    'Census_DeviceFamily': np.string_,
    'Census_ProcessorClass': np.string_,
    'Census_PrimaryDiskTypeName': np.string_,
    'Census_ChassisTypeName': np.string_,
    'Census_PowerPlatformRoleName': np.string_,
    'Census_InternalBatteryType': np.unicode_,  # not np.string_
    'Census_OSVersion': np.string_,
    'Census_OSArchitecture': np.string_,
    'Census_OSBranch': np.string_,
    'Census_OSEdition': np.string_,
    'Census_OSSkuName': np.string_,
    'Census_OSInstallTypeName': np.string_,
    'Census_OSWUAutoUpdateOptionsName': np.string_,
    'Census_GenuineStateName': np.string_,
    'Census_ActivationChannel': np.string_,
    'Census_FlightRing': np.string_
}


# In[4]:


# union of dictionaries
DICT_DTYPES = {**dict_col_num_dtypes, **dict_col_str_dtypes}

get_ipython().run_line_magic('time', 'ds = load_data(DATASET_PATH, DATASET_NAME, DICT_DTYPES)')


# In[5]:


ds.info()


# In[6]:


ds['HasDetections'].value_counts(dropna=False)


# In[6]:


# This cell is inspired by
# kaggle.com/artgor/is-this-malware-eda-fe-and-lgb-updated

#%%time

stats = []

for c in ds.columns:
    series = (ds[c].value_counts(dropna=False) == 1).value_counts()

    if series.index.isin([True]).any():
        val_1 = series[True]
    else:
        val_1 = 0

    series = (
        (ds[c].value_counts(dropna=False) != 1) and
        (ds[c].value_counts(dropna=False) < 100)
    ).value_counts()

    if series.index.isin([True]).any():
        val_100 = series[True]
    else:
        val_100 = 0

    stats.append((c,
                  ds[c].nunique(dropna=False),
                  ds[c].isna().sum() * 100 / ds.shape[0],
                  ds[c].value_counts(dropna=False).index[0],
                  ds[c].value_counts(
                      normalize=True,
                      dropna=False
                  ).values[0] * 100,
                  ds[c].dtype,
                  val_1 * 100 / ds.shape[0],
                  val_1,
                  val_100 * 100 / ds.shape[0],
                  val_100))

stats_df = pd.DataFrame(
    stats,
    columns=['Feature',
             'Unique categories (NaN included)',
             '% of NaN values',
             'Most frequent value',
             '% of most frequent value',
             'Type',
             '% of rare values (x = 1)',
             'Rare values (x = 1)',
             '% of rare values (1 < x < 100)',
             'Rare values (1 < x < 100)']
)


# In[7]:


### Case 1 - NaN values
with pd.option_context('display.max_rows', None):
    display(stats_df.sort_values(
        by=['% of NaN values'],
        ascending=False))


# In[8]:


# Potentially Unwanted Application in Windows Defender Antivirus
ds["PuaMode"].value_counts(dropna=False)


# In[9]:


ds["HasDetections"].loc[ds["PuaMode"] == "on"].value_counts()


# In[10]:


### Case 2 - most frequent value
# First eight features have few possible categories
# and one single category is more then 99% of the total
with pd.option_context('display.max_rows', None):
    display(stats_df.sort_values(
        by=['% of most frequent value'],
        ascending=False))


# In[11]:


### Case 3 - unique categories
# Understand how many bins are necessary
# for numerical features with lots of values and
# how big the number of columns of the final matrix
# will be due to the categorical features.
with pd.option_context('display.max_rows', None):
    display(stats_df.sort_values(
        by=['Unique categories (NaN included)'],
        ascending=False))


# In[12]:


### Case 4 - rare values (x = 1)
with pd.option_context('display.max_rows', None):
    display(stats_df.sort_values(
        by=['% of rare values (x = 1)'],
        ascending=False))


# In[13]:


### Case 5 - rare values (1 < x < 100)
with pd.option_context('display.max_rows', None):
    display(stats_df.sort_values(
        by=['% of rare values (1 < x < 100)'],
        ascending=False))

